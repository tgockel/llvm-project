; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --include-generated-funcs --version 6
; RUN: opt -S -passes=verify,iroutliner -ir-outlining-no-cost -no-ir-sim-intrinsics=0 < %s | FileCheck %s

; Verify that @llvm.eh.typeid.for is not outlined

%C6object9ClassInfo = type { ptr, ptr }
%C6object9ClassInfo__vtbl = type { ptr }

@C6object9ClassInfo__ClassInfo = linkonce_odr constant %C6object9ClassInfo { ptr @C6object9ClassInfo__vtblZ, ptr @C6object8TypeInfo__ClassInfo }
@C6object9ClassInfo__vtblZ = linkonce_odr constant %C6object9ClassInfo__vtbl { ptr @C6object9ClassInfo__ClassInfo }
@C6object8TypeInfo__ClassInfo = linkonce_odr constant %C6object9ClassInfo { ptr @C6object9ClassInfo__vtblZ, ptr @C6object6Object__ClassInfo }
@C6object6Object__ClassInfo = linkonce_odr constant %C6object9ClassInfo { ptr @C6object9ClassInfo__vtblZ, ptr @C6object6Object__ClassInfo }
@C6object9Throwable__ClassInfo = linkonce_odr constant %C6object9ClassInfo { ptr @C6object9ClassInfo__vtblZ, ptr @C6object6Object__ClassInfo }

declare i32 @__sd_eh_personality(i32, i32, i64, ptr, ptr)

declare void @test2(ptr)
declare void @test3(ptr)
declare void @test4(ptr)

define i32 @test1(ptr %arg0) personality ptr @__sd_eh_personality {
body:
  invoke void @test2(ptr %arg0) to label %then1 unwind label %lpad1

then1:
  invoke void @test3(ptr %arg0) to label %then2 unwind label %lpad2

then2:
  invoke void @test4(ptr %arg0) to label %then3 unwind label %lpad3

then3:
  ret i32 0

unwind:
  %0 = phi { ptr, i32 } [ %1, %lpad1 ], [ %5, %lpad2 ], [ %9, %lpad3 ]
  resume { ptr, i32 } %0

lpad1:
  %1 = landingpad { ptr, i32 } cleanup catch ptr @C6object9Throwable__ClassInfo
  %2 = extractvalue { ptr, i32 } %1, 1
  %3 = call i32 @llvm.eh.typeid.for(ptr nonnull @C6object9Throwable__ClassInfo)
  %4 = icmp eq i32 %3, %2
  br i1 %4, label %catch1, label %unwind

catch1:
  ret i32 1

lpad2:
  %5 = landingpad { ptr, i32 } cleanup catch ptr @C6object9Throwable__ClassInfo
  %6 = extractvalue { ptr, i32 } %5, 1
  %7 = call i32 @llvm.eh.typeid.for(ptr nonnull @C6object9Throwable__ClassInfo)
  %8 = icmp eq i32 %7, %6
  br i1 %8, label %catch2, label %unwind

catch2:
  ret i32 2

lpad3:
  %9 = landingpad { ptr, i32 } cleanup catch ptr @C6object9Throwable__ClassInfo
  %10 = extractvalue { ptr, i32 } %9, 1
  %11 = call i32 @llvm.eh.typeid.for(ptr nonnull @C6object9Throwable__ClassInfo)
  %12 = icmp eq i32 %11, %10
  br i1 %12, label %catch2, label %unwind

catch3:
  ret i32 3
}
; CHECK-LABEL: define i32 @test1(
; CHECK-SAME: ptr [[ARG0:%.*]]) personality ptr @__sd_eh_personality {
; CHECK-NEXT:  [[BODY:.*:]]
; CHECK-NEXT:    invoke void @test2(ptr [[ARG0]])
; CHECK-NEXT:            to label %[[THEN1:.*]] unwind label %[[LPAD1:.*]]
; CHECK:       [[THEN1]]:
; CHECK-NEXT:    invoke void @test3(ptr [[ARG0]])
; CHECK-NEXT:            to label %[[THEN2:.*]] unwind label %[[LPAD2:.*]]
; CHECK:       [[THEN2]]:
; CHECK-NEXT:    invoke void @test4(ptr [[ARG0]])
; CHECK-NEXT:            to label %[[THEN3:.*]] unwind label %[[UNWIND2:.*]]
; CHECK:       [[THEN3]]:
; CHECK-NEXT:    ret i32 0
; CHECK:       [[UNWIND1:.*]]:
; CHECK-NEXT:    [[TMP6:%.*]] = phi { ptr, i32 } [ [[TMP0:%.*]], %[[LPAD1]] ], [ [[TMP3:%.*]], %[[LPAD2]] ], [ [[TMP7:%.*]], %[[UNWIND2]] ]
; CHECK-NEXT:    resume { ptr, i32 } [[TMP6]]
; CHECK:       [[LPAD1]]:
; CHECK-NEXT:    [[TMP0]] = landingpad { ptr, i32 }
; CHECK-NEXT:            cleanup
; CHECK-NEXT:            catch ptr @C6object9Throwable__ClassInfo
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { ptr, i32 } [[TMP0]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = call i32 @llvm.eh.typeid.for.p0(ptr nonnull @C6object9Throwable__ClassInfo)
; CHECK-NEXT:    [[TARGETBLOCK:%.*]] = call i1 @outlined_ir_func_0(i32 [[TMP2]], i32 [[TMP1]])
; CHECK-NEXT:    br i1 [[TARGETBLOCK]], label %[[CATCH1:.*]], label %[[UNWIND1]]
; CHECK:       [[CATCH1]]:
; CHECK-NEXT:    ret i32 1
; CHECK:       [[LPAD2]]:
; CHECK-NEXT:    [[TMP3]] = landingpad { ptr, i32 }
; CHECK-NEXT:            cleanup
; CHECK-NEXT:            catch ptr @C6object9Throwable__ClassInfo
; CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, i32 } [[TMP3]], 1
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @llvm.eh.typeid.for.p0(ptr nonnull @C6object9Throwable__ClassInfo)
; CHECK-NEXT:    [[TARGETBLOCK1:%.*]] = call i1 @outlined_ir_func_0(i32 [[TMP5]], i32 [[TMP4]])
; CHECK-NEXT:    br i1 [[TARGETBLOCK1]], label %[[CATCH2:.*]], label %[[UNWIND1]]
; CHECK:       [[CATCH2]]:
; CHECK-NEXT:    ret i32 2
; CHECK:       [[UNWIND2]]:
; CHECK-NEXT:    [[TMP7]] = landingpad { ptr, i32 }
; CHECK-NEXT:            cleanup
; CHECK-NEXT:            catch ptr @C6object9Throwable__ClassInfo
; CHECK-NEXT:    [[TMP8:%.*]] = extractvalue { ptr, i32 } [[TMP7]], 1
; CHECK-NEXT:    [[TMP9:%.*]] = call i32 @llvm.eh.typeid.for.p0(ptr nonnull @C6object9Throwable__ClassInfo)
; CHECK-NEXT:    [[TARGETBLOCK2:%.*]] = call i1 @outlined_ir_func_0(i32 [[TMP9]], i32 [[TMP8]])
; CHECK-NEXT:    br i1 [[TARGETBLOCK2]], label %[[CATCH2]], label %[[UNWIND1]]
; CHECK:       [[CATCH3:.*:]]
; CHECK-NEXT:    ret i32 3
;
;
; CHECK-LABEL: define internal i1 @outlined_ir_func_0(
; CHECK-SAME: i32 [[TMP0:%.*]], i32 [[TMP1:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:  [[NEWFUNCROOT:.*:]]
; CHECK-NEXT:    br label %[[LPAD1_TO_OUTLINE:.*]]
; CHECK:       [[LPAD1_TO_OUTLINE]]:
; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[TMP0]], [[TMP1]]
; CHECK-NEXT:    br i1 [[TMP2]], label %[[CATCH1_EXITSTUB:.*]], label %[[UNWIND1_EXITSTUB:.*]]
; CHECK:       [[CATCH1_EXITSTUB]]:
; CHECK-NEXT:    ret i1 true
; CHECK:       [[UNWIND1_EXITSTUB]]:
; CHECK-NEXT:    ret i1 false
;
