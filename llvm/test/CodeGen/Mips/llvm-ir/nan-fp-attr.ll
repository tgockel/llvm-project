; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=mips -mcpu=mips32 | FileCheck %s --check-prefix=MIPS32R1
; RUN: llc < %s -mtriple=mips -mcpu=mips32r2 | FileCheck %s --check-prefix=MIPS32R2
; RUN: llc < %s -mtriple=mips -mcpu=mips32r2 -mattr=+abs2008 | FileCheck %s --check-prefix=MIPS32R2-ABS2K8
; RUN: llc < %s -mtriple=mips -mcpu=mips32r2 -mattr=+abs2008,+fp64 | FileCheck %s --check-prefix=MIPS32R2-ABS2K8
; RUN: llc < %s -mtriple=mips -mcpu=mips32r2 -mattr=+fp64 | FileCheck %s --check-prefix=MIPS32R2
; RUN: llc < %s -mtriple=mips -mcpu=mips32r6 | FileCheck %s --check-prefix=MIPS32R6
; RUN: llc < %s -mtriple=mips64 -mcpu=mips64 | FileCheck %s --check-prefix=MIPS64R1
; RUN: llc < %s -mtriple=mips64 -mcpu=mips64r2 | FileCheck %s --check-prefix=MIPS64R2
; RUN: llc < %s -mtriple=mips64 -mcpu=mips64r2 -mattr=+abs2008 | FileCheck %s --check-prefix=MIPS64R2-ABS2K8
; RUN: llc < %s -mtriple=mips64 -mcpu=mips64r6 | FileCheck %s --check-prefix=MIPS64R6
; RUN: llc < %s -mtriple=mips64 -mcpu=mips64r6 -mattr=+abs2008 | FileCheck %s --check-prefix=MIPS64R6-ABS2K8
; RUN: llc < %s -mtriple=mips -mcpu=mips32r2 -mattr=+micromips | FileCheck %s --check-prefix=MM
; RUN: llc < %s -mtriple=mips -mcpu=mips32r2 -mattr=+micromips,+abs2008 | FileCheck %s --check-prefix=MM-ABS2K8
; RUN: llc < %s -mtriple=mips -mcpu=mips32r2 -mattr=+micromips,+abs2008,+fp64 | FileCheck %s --check-prefix=MM-ABS2K8
; RUN: llc < %s -mtriple=mips -mcpu=mips32r2 -mattr=+micromips,+fp64 | FileCheck %s --check-prefix=MM
; RUN: llc < %s -mtriple=mips -mcpu=mips32r6 -mattr=+micromips | FileCheck %s --check-prefix=MMR6

; Test that the instruction selection for the case of `abs.s` and `abs.d`
; matches the expected behaviour. In the default case with NaNs and no "abs2008"
; mode MIPS treats abs.s and abs.d as arithmetic fp instructions triggering
; a fp exception on execution if the input is a NaN. This results in no abs.[sd]
; instructions.

; In the case where no NaNs are present is asserted or in "abs2008" mode,
; abs.[sd] instructions are selected.

declare double @llvm.fabs.f64(double)
declare float @llvm.fabs.f32(float)

define dso_local double @foo(double %a) #0 {
; MIPS32R1-LABEL: foo:
; MIPS32R1:       # %bb.0: # %entry
; MIPS32R1-NEXT:    jr $ra
; MIPS32R1-NEXT:    abs.d $f0, $f12
;
; MIPS32R2-LABEL: foo:
; MIPS32R2:       # %bb.0: # %entry
; MIPS32R2-NEXT:    jr $ra
; MIPS32R2-NEXT:    abs.d $f0, $f12
;
; MIPS32R2-ABS2K8-LABEL: foo:
; MIPS32R2-ABS2K8:       # %bb.0: # %entry
; MIPS32R2-ABS2K8-NEXT:    jr $ra
; MIPS32R2-ABS2K8-NEXT:    abs.d $f0, $f12
;
; MIPS32R6-LABEL: foo:
; MIPS32R6:       # %bb.0: # %entry
; MIPS32R6-NEXT:    jr $ra
; MIPS32R6-NEXT:    abs.d $f0, $f12
;
; MIPS64R1-LABEL: foo:
; MIPS64R1:       # %bb.0: # %entry
; MIPS64R1-NEXT:    jr $ra
; MIPS64R1-NEXT:    abs.d $f0, $f12
;
; MIPS64R2-LABEL: foo:
; MIPS64R2:       # %bb.0: # %entry
; MIPS64R2-NEXT:    jr $ra
; MIPS64R2-NEXT:    abs.d $f0, $f12
;
; MIPS64R2-ABS2K8-LABEL: foo:
; MIPS64R2-ABS2K8:       # %bb.0: # %entry
; MIPS64R2-ABS2K8-NEXT:    jr $ra
; MIPS64R2-ABS2K8-NEXT:    abs.d $f0, $f12
;
; MIPS64R6-LABEL: foo:
; MIPS64R6:       # %bb.0: # %entry
; MIPS64R6-NEXT:    jr $ra
; MIPS64R6-NEXT:    abs.d $f0, $f12
;
; MIPS64R6-ABS2K8-LABEL: foo:
; MIPS64R6-ABS2K8:       # %bb.0: # %entry
; MIPS64R6-ABS2K8-NEXT:    jr $ra
; MIPS64R6-ABS2K8-NEXT:    abs.d $f0, $f12
;
; MM-LABEL: foo:
; MM:       # %bb.0: # %entry
; MM-NEXT:    jr $ra
; MM-NEXT:    abs.d $f0, $f12
;
; MM-ABS2K8-LABEL: foo:
; MM-ABS2K8:       # %bb.0: # %entry
; MM-ABS2K8-NEXT:    jr $ra
; MM-ABS2K8-NEXT:    abs.d $f0, $f12
;
; MMR6-LABEL: foo:
; MMR6:       # %bb.0: # %entry
; MMR6-NEXT:    abs.d $f0, $f12
; MMR6-NEXT:    jrc $ra
entry:
  %0 = tail call fast double @llvm.fabs.f64(double %a)
  ret double %0
}

define dso_local float @foo_2(float %a) #0 {
; MIPS32R1-LABEL: foo_2:
; MIPS32R1:       # %bb.0: # %entry
; MIPS32R1-NEXT:    jr $ra
; MIPS32R1-NEXT:    abs.s $f0, $f12
;
; MIPS32R2-LABEL: foo_2:
; MIPS32R2:       # %bb.0: # %entry
; MIPS32R2-NEXT:    jr $ra
; MIPS32R2-NEXT:    abs.s $f0, $f12
;
; MIPS32R2-ABS2K8-LABEL: foo_2:
; MIPS32R2-ABS2K8:       # %bb.0: # %entry
; MIPS32R2-ABS2K8-NEXT:    jr $ra
; MIPS32R2-ABS2K8-NEXT:    abs.s $f0, $f12
;
; MIPS32R6-LABEL: foo_2:
; MIPS32R6:       # %bb.0: # %entry
; MIPS32R6-NEXT:    jr $ra
; MIPS32R6-NEXT:    abs.s $f0, $f12
;
; MIPS64R1-LABEL: foo_2:
; MIPS64R1:       # %bb.0: # %entry
; MIPS64R1-NEXT:    jr $ra
; MIPS64R1-NEXT:    abs.s $f0, $f12
;
; MIPS64R2-LABEL: foo_2:
; MIPS64R2:       # %bb.0: # %entry
; MIPS64R2-NEXT:    jr $ra
; MIPS64R2-NEXT:    abs.s $f0, $f12
;
; MIPS64R2-ABS2K8-LABEL: foo_2:
; MIPS64R2-ABS2K8:       # %bb.0: # %entry
; MIPS64R2-ABS2K8-NEXT:    jr $ra
; MIPS64R2-ABS2K8-NEXT:    abs.s $f0, $f12
;
; MIPS64R6-LABEL: foo_2:
; MIPS64R6:       # %bb.0: # %entry
; MIPS64R6-NEXT:    jr $ra
; MIPS64R6-NEXT:    abs.s $f0, $f12
;
; MIPS64R6-ABS2K8-LABEL: foo_2:
; MIPS64R6-ABS2K8:       # %bb.0: # %entry
; MIPS64R6-ABS2K8-NEXT:    jr $ra
; MIPS64R6-ABS2K8-NEXT:    abs.s $f0, $f12
;
; MM-LABEL: foo_2:
; MM:       # %bb.0: # %entry
; MM-NEXT:    jr $ra
; MM-NEXT:    abs.s $f0, $f12
;
; MM-ABS2K8-LABEL: foo_2:
; MM-ABS2K8:       # %bb.0: # %entry
; MM-ABS2K8-NEXT:    jr $ra
; MM-ABS2K8-NEXT:    abs.s $f0, $f12
;
; MMR6-LABEL: foo_2:
; MMR6:       # %bb.0: # %entry
; MMR6-NEXT:    abs.s $f0, $f12
; MMR6-NEXT:    jrc $ra
entry:
  %0 = tail call fast float @llvm.fabs.f32(float %a)
  ret float %0
}

attributes #0 = { nounwind }
