; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx | FileCheck %s --check-prefixes=AVX
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx512vl | FileCheck %s --check-prefixes=AVX512

; Verify that we generate a single OR instruction for a scalar, vec128, and vec256
; FNABS(x) operation -> FNEG (FABS(x)).
; If the FABS() result isn't used, the AND instruction should be eliminated.
; PR20578: http://llvm.org/bugs/show_bug.cgi?id=20578

define float @scalar_no_abs(float %a) {
; AVX-LABEL: scalar_no_abs:
; AVX:       # %bb.0:
; AVX-NEXT:    vorps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm0
; AVX-NEXT:    retq
;
; AVX512-LABEL: scalar_no_abs:
; AVX512:       # %bb.0:
; AVX512-NEXT:    vpord {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to4}, %xmm0, %xmm0
; AVX512-NEXT:    retq
  %fabs = tail call float @llvm.fabs.f32(float %a) #1
  %fsub = fsub float -0.0, %fabs
  ret float %fsub
}

define float @scalar_uses_abs(float %a) {
; AVX-LABEL: scalar_uses_abs:
; AVX:       # %bb.0:
; AVX-NEXT:    vandps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm1
; AVX-NEXT:    vorps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm0
; AVX-NEXT:    vmulss %xmm1, %xmm0, %xmm0
; AVX-NEXT:    retq
;
; AVX512-LABEL: scalar_uses_abs:
; AVX512:       # %bb.0:
; AVX512-NEXT:    vpandd {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to4}, %xmm0, %xmm1
; AVX512-NEXT:    vpord {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to4}, %xmm0, %xmm0
; AVX512-NEXT:    vmulss %xmm1, %xmm0, %xmm0
; AVX512-NEXT:    retq
  %fabs = tail call float @llvm.fabs.f32(float %a) #1
  %fsub = fsub float -0.0, %fabs
  %fmul = fmul float %fsub, %fabs
  ret float %fmul
}

define <4 x float> @vector128_no_abs(<4 x float> %a) {
; AVX-LABEL: vector128_no_abs:
; AVX:       # %bb.0:
; AVX-NEXT:    vorps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm0
; AVX-NEXT:    retq
;
; AVX512-LABEL: vector128_no_abs:
; AVX512:       # %bb.0:
; AVX512-NEXT:    vpord {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to4}, %xmm0, %xmm0
; AVX512-NEXT:    retq
  %fabs = tail call <4 x float> @llvm.fabs.v4f32(< 4 x float> %a) #1
  %fsub = fsub <4 x float> <float -0.0, float -0.0, float -0.0, float -0.0>, %fabs
  ret <4 x float> %fsub
}

define <4 x float> @vector128_uses_abs(<4 x float> %a) {
; AVX-LABEL: vector128_uses_abs:
; AVX:       # %bb.0:
; AVX-NEXT:    vandps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm1
; AVX-NEXT:    vorps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm0
; AVX-NEXT:    vmulps %xmm1, %xmm0, %xmm0
; AVX-NEXT:    retq
;
; AVX512-LABEL: vector128_uses_abs:
; AVX512:       # %bb.0:
; AVX512-NEXT:    vpandd {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to4}, %xmm0, %xmm1
; AVX512-NEXT:    vpord {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to4}, %xmm0, %xmm0
; AVX512-NEXT:    vmulps %xmm1, %xmm0, %xmm0
; AVX512-NEXT:    retq
  %fabs = tail call <4 x float> @llvm.fabs.v4f32(<4 x float> %a) #1
  %fsub = fsub <4 x float> <float -0.0, float -0.0, float -0.0, float -0.0>, %fabs
  %fmul = fmul <4 x float> %fsub, %fabs
  ret <4 x float> %fmul
}

define <8 x float> @vector256_no_abs(<8 x float> %a) {
; AVX-LABEL: vector256_no_abs:
; AVX:       # %bb.0:
; AVX-NEXT:    vorps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm0, %ymm0
; AVX-NEXT:    retq
;
; AVX512-LABEL: vector256_no_abs:
; AVX512:       # %bb.0:
; AVX512-NEXT:    vpord {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to8}, %ymm0, %ymm0
; AVX512-NEXT:    retq
  %fabs = tail call <8 x float> @llvm.fabs.v8f32(< 8 x float> %a) #1
  %fsub = fsub <8 x float> <float -0.0, float -0.0, float -0.0, float -0.0, float -0.0, float -0.0, float -0.0, float -0.0>, %fabs
  ret <8 x float> %fsub
}

define <8 x float> @vector256_uses_abs(<8 x float> %a) {
; AVX-LABEL: vector256_uses_abs:
; AVX:       # %bb.0:
; AVX-NEXT:    vandps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm0, %ymm1
; AVX-NEXT:    vorps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm0, %ymm0
; AVX-NEXT:    vmulps %ymm1, %ymm0, %ymm0
; AVX-NEXT:    retq
;
; AVX512-LABEL: vector256_uses_abs:
; AVX512:       # %bb.0:
; AVX512-NEXT:    vpandd {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to8}, %ymm0, %ymm1
; AVX512-NEXT:    vpord {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to8}, %ymm0, %ymm0
; AVX512-NEXT:    vmulps %ymm1, %ymm0, %ymm0
; AVX512-NEXT:    retq
  %fabs = tail call <8 x float> @llvm.fabs.v8f32(<8 x float> %a) #1
  %fsub = fsub <8 x float> <float -0.0, float -0.0, float -0.0, float -0.0, float -0.0, float -0.0, float -0.0, float -0.0>, %fabs
  %fmul = fmul <8 x float> %fsub, %fabs
  ret <8 x float> %fmul
}

declare <4 x float> @llvm.fabs.v4f32(<4 x float> %p)
declare <8 x float> @llvm.fabs.v8f32(<8 x float> %p)

declare float @llvm.fabs.f32(float)

attributes #1 = { readnone }

